% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/libFM2.R
\name{libFM2}
\alias{libFM2}
\alias{libFM2.data.frame}
\alias{libFM2.matrix}
\alias{libFM2.dgCMatrix}
\alias{libFM2.default}
\title{libFM2 factorization machines}
\usage{
libFM2(train, test, ...)

\method{libFM2}{data.frame}(train, test, formula, validation, grouping,
  scale_factors = FALSE, ...)

\method{libFM2}{matrix}(train, test, y_train, y_test, validation, y_validation,
  grouping, ...)

\method{libFM2}{dgCMatrix}(train, test, y_train, y_test, validation,
  y_validation, grouping, ...)

\method{libFM2}{default}(train, test, global_bias = TRUE,
  variable_bias = TRUE, dim = 8, task = c("c", "r"), method = c("mcmc",
  "sgd", "als", "sgda"), init_stdev = 0.1, regular = c(0, 0, 0),
  learn_rate = 0.1, validation, verbosity = 0, iter = 100, burn = 0,
  exe_loc, grouping, seed = NULL, outloc = NULL, modelloc = NULL, ...)
}
\arguments{
\item{train}{training data.frame, (sparse) matrix, or character vector}

\item{test}{testing data.frame, (sparse) matrix, or character vector}

\item{...}{other, unused, arguments}

\item{formula}{formula of covariates included}

\item{validation}{validation data.frame, (sparse) matrix, or character vector used for
adaptive SGD}

\item{grouping}{logical scalar or integer vector. See details}

\item{y_train, y_test, y_validation}{numeric vectors of responses when train,
test, and validation are matrices}

\item{global_bias}{whether to include an overall/global bias term}

\item{variable_bias}{whether to include variable main effects/biases}

\item{dim}{dimension of the two-way interaction}

\item{task}{classifcation or regression}

\item{method}{learning method}

\item{init_stdev}{standard deviation used for initialization
of 2-way factors}

\item{regular}{length 3 vector of regularization parameters for
global bias, variable biases, and interactions, respectively. Used with
SGD and ALS}

\item{learn_rate}{learning rate used for SGD and adaptive SGD}

\item{verbosity}{how much feedback to give}

\item{iter}{number of iterations}

\item{burn}{number of burn-in iterations to be discarded}

\item{exe_loc}{location of libFM.exe executable (if not in the PATH)}

\item{seed}{integer value of the seed for the random number generator. Only implemented on version 1.4.2 or greater}

\item{outloc}{string filename for output}

\item{modelloc}{string filename for writing the FM model}
}
\value{
A vector of the predicted values/probabilities
}
\description{
libFM2 factorization machines
}
\details{
See the libFM manual, \url{http://www.libfm.org/libfm-1.42.manual.pdf},
 for details on the parameters.

 For grouping, if specifying model with a formula, this should be a logical
 of whether to group levels of a factor variable. If set to TRUE, each variable in
 the formula gets its own group. If specifying the model with
 a design matrix, this should be an integer vector of the same length as the
 number of columns in the design matix, where each integer specifies the group
 which the variable belongs to.

 If the function is not working, make sure that the directory is in the PATH
 by running \code{Sys.getenv('PATH')}. It is assumed that the executable is named
 \code{libFM}. You can verify that the executable is being found and works by
 running \code{system("libFM -help")} in the R console. See the README on
 \url{https://github.com/andland/libFMexe} for some more information on installation.
}
\section{Methods (by class)}{
\itemize{
\item \code{data.frame}: 

\item \code{matrix}: 

\item \code{dgCMatrix}: 

\item \code{default}: 
}}

\examples{
\dontrun{
data(movie_lens)
train_rows = sample.int(nrow(movie_lens), nrow(movie_lens) * 2 / 3)
train = movie_lens[train_rows, ]
test  = movie_lens[-train_rows, ]

outFM = libFM2(train, test, Rating ~ User + Movie,
               task = "r", dim = 10, iter = 500)
predFM = read.table(outFM$outloc, header = FALSE)$V1

mean((predFM - test$Rating)^2)

# the same can be done slightly more slowly with sparse matrices

train_mat = Matrix::sparse.model.matrix(Rating ~ User + Movie - 1, train)
test_mat = Matrix::sparse.model.matrix(Rating ~ User + Movie - 1, test)

outFM = libFM2(train_mat, test_mat, train$Rating, test$Rating,
               task = "r", dim = 10, iter = 500)
predFM = read.table(outFM$outloc, header = FALSE)$V1

mean((predFM - test$Rating)^2)
}

}
\references{
Steffen Rendle (2012): Factorization Machines with libFM, in ACM Trans.
Intell. Syst. Technol., 3(3), May.
}
